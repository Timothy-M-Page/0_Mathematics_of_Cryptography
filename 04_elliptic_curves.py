import math

"""
Integer solutions (x, y) to the elliptic curve y**2 = x**3 + a*x + b mod p
with integer parameters a and b and prime p, may form a group when the curve 
is non-singular, that is there are no repeated roots hence the curve is smooth.

Given a non singular curve with parameters a, b and p. The set of tuples
(x, y) mod p that satisfy this equation may be given a group
operation defined by drawing a tangent through the two points and
identifying the sum of the two points to be the reflection in the x axis 
of the unique third point at the intersection of this tangent with the curve.

A group identity may be identified with a point at infinity
we will denote this with the tuple ("O", "O"). This point is a mathematical
object in the projective plane that, by construction, satisfies the axioms
of the group identity under the construction of tangents in the operation. 

With this, the operation may be defined on all points, including
edge cases such as a point added to itself, or a point on the x-axis add to
itself, where the tangent is a vertical line, now mapped to the identity.

With these definitions of identity and operation the set of tuples of 
integer solutions to an elliptic curve forms an commutative group. 

The number of tuples in this group has no known exact general formula.
The Hasse-Weil Bound states that the number of points is roughly p + 1.
Mathematically, the bound states that for a curve mod p:

| number of points - (p + 1) | <= 2 sqrt(p)

As the group is commutative it can always be generated by at most two points.
In some cases it is generated by one point, forming a cyclic group, useful for
cryptographic purposes.
"""

identity = ("O", "O")


def modular_inverse(g: int, mod: int) -> int:
    if math.gcd(g, mod) != 1:
        raise ValueError(f'{g} has no inverse mod {mod}.')
    return pow(g, -1, mod)


def elliptic_curve_group(curve_params: tuple[int, int, int]) -> list[tuple]:
    # Set of points in the elliptic curve group.
    a, b, p = curve_params
    if 4 * a ** 3 + 27 * b ** 2 == 0:
        raise ValueError('Discriminant 4a^3 + 27b^2 != 0 mod p.')
    group = [identity]
    for i in range(p):
        for j in range(p):
            if i ** 2 % p == (j ** 3 + a * j + b) % p:
                group.append((j, i))
    return group


def add_points(curve_params: tuple[int, int, int],
               point1: tuple, point2: tuple) -> tuple:
    # All possible cases of two points being added.
    a, b, p = curve_params

    if point1 == identity:
        return point2
    if point2 == identity:
        return point1

    if point1 != point2 and point2[0] == point1[0]:
        return identity

    if point1 != point2 and point1[0] != point2[0]:
        m = ((point2[1] - point1[1]) *
             modular_inverse((point2[0] - point1[0]), p)) % p
        c = point1[1] - m * point1[0] % p
        x = (m**2 - point2[0] - point1[0]) % p
        y = -(m*x + c) % p
        return x, y

    if point1 == point2 and point1[1] != 0:
        m = ((3*(point1[0]**2) + a) * modular_inverse(2*point1[1], p)) % p
        c = (point1[1] - m * point1[0]) % p
        x = (m**2 - point2[0] - point1[0]) % p
        y = -(m*x + c) % p
        return x, y

    if point1 == point2 and point1[1] == 0:
        return identity


def point_exponent(curve_params: tuple[int, int, int],
                   point1: tuple, exponent: int) -> tuple:
    if exponent == 0:
        return identity

    result = identity
    power = point1
    # Use double-and-add method for quick exponentiation.
    while exponent > 0:
        if exponent % 2 == 1:  # If the current bit is 1, add current power.
            result = add_points(curve_params, result, power)
        power = add_points(curve_params, power, power)
        exponent //= 2  # Move to the next bit.
    return result


def point_subgroup(curve_params: tuple[int, int, int],
                   point1: tuple) -> list[tuple]:
    # Group generated by a point on the elliptic curve (a, b, p).
    subgroup = []
    power = point1
    while power not in subgroup:
        subgroup.append(power)
        power = add_points(curve_params, power, point1)
    return subgroup


def group_generators(curve_params: tuple[int, int, int]) -> list[tuple]:
    # Generators of the group for the elliptic curve (a, b, P).
    group_size = len(elliptic_curve_group(curve_params))
    generators = []
    for point in elliptic_curve_group(curve_params):
        if len(point_subgroup(curve_params, point)) == group_size:
            generators.append(point)
    return generators
